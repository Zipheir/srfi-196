<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 196: Range Objects</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>

  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI logo" /></a>196: Range Objects</h1>

<p>by John Cowan (text), Wolfgang Corcoran-Mathe (implementation)</p>

<h2>Status</h2>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+196+at+srfi+dotschemers+dot+org">srfi-196@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-196">archive</a>.</p>
<ul>
  <li>Received: 2020-05-17</li>
  <li>60-day deadline: 2020-07-16</li>
  <li>Draft #1 published: 2020-05-17</li>
  <li>Draft #2 published: 2020-07-16</li>
  <li>Draft #3 published: 2020-07-19</li>
  <li>Draft #4 published: 2020-08-26</li>
  <li>Draft #5 published: 2020-08-28</li>
  <li>Draft #6 published: 2020-08-29</li>
  <li>John Cowan's <a href="https://github.com/johnwcowan/srfi-196">personal
    Git repo for this SRFI</a> for reference while the SRFI is in
    <em>draft</em> status (<a href="https://htmlpreview.github.io/?https://github.com/johnwcowan/srfi-196/blob/master/srfi-196.html">preview</a>)</li>
</ul>

<h2>Abstract</h2>

<p>Ranges are immutable collections that can be enumerated but are
represented algorithmically rather than by a per-element data
structure.  This SRFI defines a large subset of the sequence operations
defined on lists, vectors, and other collections.  If necessary,
a range can be converted to a list or vector of its elements or a generator
that will lazily produce each element in the range.</p>

<h2>Issues</h2>

None at present.

<h2>Rationale</h2>

<p>One of the most common things to do in programming is to execute
a block of code a fixed number of times, with access to the index
used for the iteration.  Indeed, it is so common that there is generally
a standard syntax for providing it, generally involving the keyword
<code>for</code> (or if not, as in Fortran and Lisp, the word
<code>do</code>).  It is also usual to be able to provide a lower bound,
generally defaulting to 0 or 1, as well as step size, allowing
iterations through a sequence of odd numbers, or multiples of 10,
or whatever.</p>

<p>Languages with higher order functions, however, provide a second
approach to such loops: construct a sequence of numbers and apply
a function to each element of the sequence.  SRFI 1's <code>iota</code>
and the standard <code>for-each</code> procedures make this easy:
<code>(for-each (lambda (i) ...) (iota 0 10))</code>
will execute the expressions represented as <code>...</code>
with <code>i</code> bound to the numbers 0 through 9, as
the generated list includes the lower bound and excludes the upper bound.</p>

<p>This approach is less feasible as the number of numbers grows.
To iterate a million times involves constructing a list of a million
numbers to be iterated over and immediately discarded as garbage.
This is not something you want to do in the inner loop of your code.
The range objects of this SRFI represent such sequences using only
a small fixed amount of storage.  Using
<code>(range-for-each (lambda (i) ...) (numeric-range 0 1000000))</code>
iterates a million times but with less space overhead than
<code>iota</code>'s list of ten elements.
They can be thought of as compactly stored vectors.</p>

<p>In addition, there are other sequences besides integers from
which a range may be drawn.  In particular, inexact numbers can
also specify ranges: <code>(numeric-range 0.0 1.0 0.1)</code>
specifies the sequence 0.0, 0.1, ... 0.9,
at least when inexact numbers are represented
as IEEE 754 binary double floats (as is usually the case).
Roundoff error is still possible by multiplying, but it is
greatly reduced compared to accumulated error by repeated adding.
</p>
<p>Two more examples:
</p>
<ul>
<li>The basic Latin capital letters A-Z can be specified using
a range constructed by <code>(range 26
(lambda (n) (integer->char (+ 65 n))))</code>.
</li>
<li>
The geometric sequence 1, 1/2, 1/4, &hellip;, 1/512 can be expressed by
<code>(range 10 (lambda (n) (expt 1/2 n)))</code>.
</li></ul>

<h2>Specification</h2>

<p>Ranges belong to a disjoint type.</p>

<p> The size of a range object is independent of the number of
elements it contains, except for <em>vector-style ranges</em>.
These are returned only by certain procedures noted below.  Such
ranges cannot compute their results on the fly, and so must compute
them in advance and store them in a vector or similar O(1) random
access data structure.  As a result, their size is proportional to
the number of elements; however, performance guarantees are maintained.
</p>

<p>Statements about running time exclude time spent in the indexer procedure.
</p>
<p>This SRFI recommends, but does not require, that Scheme implementations
which also provide <a href="https://srfi.schemers.org/srfi-42/srfi-42.html">SRFI 42</a>
modify it so that the typed generator <code>:range</code> also accepts
a single argument which is a range in the sense of this SRFI.
This feature should be used with caution, as SRFI 42 loops expect
that <code>:range</code> iterates only over exact rationals.
</p>

<p>The following names are used for arguments to procedures:</p>

<p><em>obj</em>: Any Scheme object.</p>

<p><em>range</em>: A range object.</p>

<p><em>pred</em>: A predicate that accepts zero or more arguments.</p>

<p><em>equal</em>: A predicate that accepts two arguments and returns a
boolean value. It is not necessarily an equivalence relation.</p>

<p><em>proc</em>: A procedure that accepts zero or more arguments and
returns zero or more values.</p>

<p><em>list</em>: A Scheme list.</p>

<p><em>vector</em>: A Scheme vector.</p>

<p><em>string</em>: A Scheme string.</p>
<p>It is an error (unless otherwise noted) if the procedures are passed
arguments that do not have the type implied by the argument names.</p>

<h3 id="constructors">Constructors</h3>
<p><code>(range</code>&nbsp;<em>length indexer</em><code>)</code></p>
<p>Returns a range whose length (number of elements) is <i>length</i>.
The <i>indexer</i> procedure returns the <i>n</i>th element
(where 0 &#x2264; <i>n</i> &lt; <i>length</i>)
of the range given <i>n</i>.
This procedure must run in O(1) time.</p>

<p><code>(numeric-range</code>&nbsp;<em>start end</em> [<em>step</em>]<code>)</code></p>
<p>Returns a numeric range, a special case of a range specified by an
inclusive lower bound <em>start</em>, an exclusive upper bound <em>end</em>, and a
<em>step</em> value (default 1), all of which can be exact or inexact real
numbers.  This range produces the sequence</p>
<blockquote>
<em>start</em><code>, (+&nbsp;</code><em>start&nbsp;step</em><code>),
(+&nbsp;</code><em>start</em><code>&nbsp;(* 2 </code><em>step</em><code>)),
&hellip;, (+&nbsp;</code><em>start</em><code>
(*&nbsp;</code><em>n step</em><code>))</code>,
</blockquote>
<p>where <em>n</em> is the greatest integer such that
<code>(+&nbsp;</code><em>start</em><code> (*&nbsp;</code><em>n step</em><code>))</code>
&lt; <em>end</em> if <em>step</em> is positive, or such that
<code>(+&nbsp;</code><em>start</em><code> (*&nbsp;</code><em>n step</em><code>))</code>
&gt; <em>end</em> if <em>step</em> is negative. It is is an error if an
<em>n</em> satisfying this condition cannot be determined, or if
<em>step</em> is numerically zero.
This procedure must run in O(1) time.</p>

<p>Note that an effect of this definition is that the elements of
a range over inexact numbers are enumerated by multiplying the index
by the step value rather than by adding the step value to itself
repeatedly.  This reduces the likelihood of roundoff errors.</p>

<p><code>(vector-range</code>&nbsp;<em>vector</em><code>)</code></p>
<p>Returns a range whose elements are those of <em>vector</em>.
The size of the result is fixed once the size of <em>vector</em>
has been excluded.  It is an error to mutate <em>vector</em>.</p>

<p><code>(string-range</code> <em>string</em><code>)</code></p>
<p>Returns a range whose elements are those of <em>string</em>. It is
an error to mutate <em>string</em>.</p>

<p><code>(range-append</code>&nbsp;<em>range</em> ...<code>)</code></p>
<p>Returns a range whose elements are the elements of the <em>ranges</em>
in order.
It may return a vector-style range.

<h3 id="predicates">Predicates</h3>

<p><code>(range?</code>&nbsp;<em>obj</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>obj</em> is a range and <code>#f</code>
otherwise.
This procedure must run in O(1) time.</p>

<p><code>(range=?</code>&nbsp;<em>equal range1 range2 ...</em><code>)</code></p>
<p>Returns <code>#t</code> if all the <em>ranges</em> are of the same
length and if their corresponding values are the same in the sense of
<em>equal</em>, and <code>#f</code> otherwise.
</p>
<h3 id="accessors">Accessors</h3>

<p><code>(range-length</code>&nbsp;<em>range</em><code>)</code></p>
<p>Returns the length (number of elements) of <em>range</em>.
This procedure must run in O(1) time.</p>

<p><code>(range-ref</code>&nbsp;<em>range n</em><code>)</code></p>
<p>Returns the <em>n</em>th element of <em>range</em>. It is an error if
<em>n</em> is less than 0 or greater than or equal to the length of
<em>range</em>.
This procedure must run in O(1) time.</p>

<p><code>(range-first</code>&nbsp;<em>range</em><code>)</code></p>
<p>Equivalent to <code>(range-ref</code>&nbsp;<em>range</em>
<code>0)</code>.
This procedure must run in O(1) time.</p>

<p><code>(range-last</code>&nbsp;<em>range</em><code>)</code></p>
<p>Equivalent to <code>(range-ref</code>&nbsp;<em>range</em> <code>(-
(range-length</code>&nbsp;<em>range</em><code>) 1))</code>.
This procedure must run in O(1) time.</p>

<h3 id="iteration">Iteration</h3>

<p><code>(range-split-at</code>&nbsp;<em>range index</em><code>)</code></p>
<p>Returns two values:
<code>(range-take</code>&nbsp;<em>range index</em><code>)</code> and
<code>(range-drop</code>&nbsp;<em>range index</em><code>)</code>.
It is an error if <em>index</em> is not an exact integer
between 0 and the length of <em>range</em>, both inclusive.
This procedure must run in O(1) time.</p>
<p><code>(subrange</code>&nbsp;<em>range start end</em><code>)</code></p>
<p>Returns a range which contains the elements of
<i>range</i> from index <i>start</i>, inclusive, through index
<i>end</i>, exclusive.
This procedure must run in O(1) time.</p>

<p><code>(range-take</code>&nbsp;<em>range count</em><code>)</code><br/>
<code>(range-take-right</code>&nbsp;<em>range count</em><code>)</code></p>
<p>Returns a range which contains the first/last <em>count</em> elements of
<em>range</em>.
These procedures must run in O(1) time.</p>

<p><code>(range-drop</code>&nbsp;<em>range count</em><code>)</code><br/>
<code>(range-drop-right</code>&nbsp;<em>range count</em><code>)</code></p>
<p>Returns a range which contains all except the first/last <em>count</em> elements
of <em>range</em>.
These procedures must run in O(1) time.</p>

<p><code>(range-count</code>&nbsp;<em>pred range1 range2</em> ...<code>)</code></p>
<p>Applies <em>pred</em> element-wise to the elements of
<em>ranges</em> and returns the number of applications which returned
true values. If more than one <em>range</em> is given and not all ranges
have the same length, <em>range-count</em> terminates when the shortest
range is exhausted.
This procedure must run in O(<em>n</em>) time.</p>

<p><code>(range-any</code>&nbsp;<em>pred range1 range2</em> ...<code>)</code></p>
<p>Applies <em>pred</em> element-wise to the elements of the
<em>ranges</em> and returns true if <em>pred</em> returns true on any
application. Specifically it returns the last value returned by
<em>pred</em>. Otherwise, <code>#f</code> is returned. If more than
one <em>range</em> is given and not all ranges have the same length,
<em>range-any</em> terminates when the shortest range is exhausted.
This procedure must run in O(<em>n</em>) time.</p>

<p><code>(range-every</code>&nbsp;<em>pred range</em><code>)</code></p>
<p>Applies <em>pred</em> element-wise to the elements of the
<em>ranges</em> and returns true if <em>pred</em> returns true on
every application. Specifically it returns the last value returned by
<em>pred</em> or <code>#t</code> if <em>pred</em> was never invoked.
Otherwise, <code>#f</code> is returned. If more than one
<em>range</em> is given and not all ranges have the same length,
<em>range-every</em> terminates when the shortest range is exhausted.
This procedure must run in O(<em>n</em>) time.
</p>

<p><code>(range-map</code>&nbsp;<em>proc range1 range2</em> ...<code>)</code><br/>
<code>(range-map-&gt;list</code>&nbsp;<em>proc range1 range2</em> ...<code>)</code><br/>
<code>(range-map-&gt;vector</code>&nbsp;<em>proc range1 range2</em> ...<code>)</code></p>
<p>Applies <em>proc</em> element-wise to the elements of the
<em>ranges</em> and returns a range/list/vector of the results, in
order. If more than one <em>range</em> is given and not all ranges
have the same length, these procedures terminate when the shortest
range is exhausted. The dynamic order in which <em>proc</em> is
actually applied to the elements is unspecified. The
<code>range-map</code> procedure may return a vector-style range.
These procedures must run in O(<em>n</em>) time.
</p>

<p><code>(range-for-each</code>&nbsp;<em>proc range1 range2</em> ...<code>)</code></p>
<p>Applies <em>proc</em> element-wise to the elements of the
<code>ranges</code> in order. Returns an unspecified result. If more
than one <em>range</em> is given and not all ranges have the same
length, <em>range-for-each</em> terminates when the shortest range is
exhausted.
This procedure must run in O(<em>n</em>) time.</p>

<p><code>(range-filter-map</code> <em>proc range1 range2</em> ...<code>)</code><br/>
<code>(range-filter-map-&gt;list</code> <em>proc range1 range2</em> ...<code>)</code></p>
<p>Applies <em>proc</em> element-wise to the elements of the <em>ranges</em> and
returns a range/list of the true values returned by <em>proc</em>.
If more than one <em>range</em> is given and not all ranges
have the same length, these procedures terminate when the shortest
range is exhausted. The dynamic order in which <em>proc</em> is
actually applied to the elements is unspecified. The
<code>range-filter-map</code> procedure may return a vector-style range.
These procedures must run in O(<em>n</em>) time.</p>

<p><code>(range-filter</code>&nbsp;<em>pred range</em><code>)</code><br/>
<code>(range-filter-&gt;list</code>&nbsp;<em>pred range</em><code>)</code><br/>
<code>(range-remove</code>&nbsp;<em>pred range</em><code>)</code><br/>
<code>(range-remove-&gt;list</code>&nbsp;<em>pred range</em><code>)</code><br/>
<p>Returns a range/list containing the elements of <em>range</em> that satisfy / do
not satisfy <em>pred</em>.
The <code>range-filter</code> and <code>range-remove</code>
procedures may return a vector-style range.
These procedures must run in O(<em>n</em>) time.</p>

<p>The <code>range-filter</code> and <code>range-remove</code>
procedures eagerly compute their results and return specialized
ranges that store arbitrary elements.  As a result, their size is
proportional to the number of elements in <em>range</em>.</p>

<p><code>(range-fold</code>&nbsp;<em>kons nil range1 range2</em> ...<code>)</code><br/>
<code>(range-fold-right</code>&nbsp;<em>kons nil range1 range2</em> ...<code>)</code></p>
<p>Folds <em>kons</em> over the elements of <em>ranges</em> in order / reverse order.
<em>kons</em> is applied as
<code>(</code><em>kons state</em> <code>(range-ref</code> <em>range1 i</em><code>)</code> <code>(range-ref</code> <em>range2 i</em><code>)</code> &hellip;<code>)</code>
where <em>state</em> is the result of the previous invocation and <em>i</em> is the
current index. For the first
invocation, <em>nil</em> is used as the first argument. Returns the result of
the last invocation, or <em>nil</em> if there was no invocation.
If more
than one <em>range</em> is given and not all ranges have the same
length, these procedures terminate when the shortest range is
exhausted.
These procedures must run in O(<em>n</em>) time.</p>

<h3 id="searching">Searching</h3>

<p><code>(range-index</code>&nbsp;<em>pred range1 range2</em>... <code>)</code><br/>
<code>(range-index-right</code>&nbsp;<em>pred range1 range2</em>... <code>)</code></p>
<p>Applies <em>pred</em> element-wise to the elements of
<em>ranges</em> and returns the index of the first/last element at
which <em>pred</em> returns true. Otherwise, returns <code>#f</code>.
If more than one <em>range</em> is given and not all ranges have the same
length, <em>range-index</em> terminates when the shortest range is
exhausted. It is an error if the ranges passed to <em>range-index-right</em>
do not all have the same lengths.
These procedures must run in O(<em>n</em>) time.</p>

<p><code>(range-take-while</code>&nbsp;<em>pred range</em><code>)</code><br/>
<code>(range-take-while-right</code>&nbsp;<em>pred range</em><code>)</code></p>
<p>Returns a range containing the leading/trailing elements of <em>range</em> that satisfy
<em>pred</em> up to the first/last one that does not.
These procedures must run in O(<em>n</em>) time.</p>

<p><code>(range-drop-while pred</code>&nbsp;<em>range</em><code>)</code><br/>
<code>(range-drop-while-right</code>&nbsp;<em>pred range</em><code>)</code></p>
<p>Returns a range that omits leading/trailing elements of <em>range</em> that satisfy
<em>pred</em> until the first/last one that does not.
These procedures must run in O(<em>n</em>) time.</p>

<h3 id="conversion">Conversion</h3>

<p><code>(range-&gt;list</code>&nbsp;<em>range</em><code>)</code><br/>
<code>(range-&gt;vector</code>&nbsp;<em>range</em><code>)</code><br/>
<code>(range-&gt;string</code>&nbsp;<em>range</em><code>)</code></p>
<p>Returns a list/vector/string containing the elements of <em>range</em> in order.
It is an error to modify the result of <code>range-&gt;vector</code>
or of <code>range-&gt;string</code>.  In the case of <code>range-&gt;string</code>,
it is an error if any element of <em>range</em> is not a character.
These procedures must run in O(<em>n</em>) time.</p>

<p><code>(vector-&gt;range</code> <em>vector</em><code>)</code></p>
<p>Returns a range whose elements are those of <em>vector</em>.
Note that, unlike in the case of <code>vector-range</code>, it is not
an error to mutate <em>vector</em>; future mutations of
<em>vector</em> are guaranteed not to affect the range returned by
<code>vector-&gt;range</code>.</p>

<p><code>(range-&gt;generator</code>&nbsp;<em>range</em><code>)</code></p>
<p>Returns a SRFI 158 generator that generates the elements of <em>range</em>
in order.
This procedure must run in O(1) time,
and each call of the generator must run in O(1) time.

<h2>Implementation</h2>

<p>The sample implementation is in the repository of this SRFI.
An R7RS library file and a separate file containing the actual
implementation are provided, along with a test file that
works with SRFI 78, but is self-contained if SRFI 78 does not exist.
The implementation uses SRFI 1 and can take
advantage of SRFI 145 (<code>assume</code>) if it is present.</p>


<h2>Acknowledgements</h2>

<p>Without <a href="https://docs.python.org/3.8/library/stdtypes.html#ranges">Python's <code>range</code> object</a>,
this SRFI would not exist.  Thanks also to the contributors on the SRFI 196 mailing list.
</p>

<h2>Copyright</h2>
Copyright &copy; John Cowan, Wolfgang Corcoran-Mathe (2020).

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.
<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
